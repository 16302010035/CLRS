习题2.3-2 不适用哨兵的merge，见Text2_3_MergeSort.java之new_merge()方法

习题2.3-3  用数学归纳法证明等式成立。
1. 当k=1时， n=2^k=2，等式成立。
2. 假设k=i时，
	T(n)=T(2^i) = 2T(2^i/2) + 2^i = 2^i*lg2^i   成立
3. 则k=i+1时
	T(n)=T(2^(i+1))=2*T(2^(i+1)/2) + 2^(i+1)
		=2*T(2^i) + 2^i*2		//把等式2 T(2^i0 = 2^i*lg2^i代入
		=2*2^i*lg2^i + 2^i*2
		=2^(i+1)*(lg2^i + 1)
		= 2^(i+1)*(lg2^i + lg2)
		=2^(i+1)*log2^(i+1)
	证毕。
	
习题2.3-4 插入排序最坏情况的递归式
1. 插入排序递归写法见 "prac234_InsertSort_Recursive.java"
2. 递归式：
	1. n=1, 为常量c*1；
	2. n>1时，我们把递归过程分为分解、处理、合并三部分。
		其中分解、合并部分都是n的线性函数，记为c1*n, c2*n, 可以合并为 c*n
		处理部分，假设规模为n,当i=1...n时，最坏情况下的比较次数分别为
		i  			1	2	3  。。。n
		比较次数		0	1	2 ... n-1
		故全部比较次数为 0 + 1 + 2 + ... + n-1 = (n-1)(n-2)/2
	         可以记为(n-1)(n-2)/2 + c*n
	 综上，递归式为：
	T(n) = c  					(n=1)
		   (n-1)(n-2)/2 + c*n    (n>1)
		   

习题2.3-6 （答案不确定） 插入排序的while顺序查找部分改成二分查找时，性能能否提高到O(nlgn)？
	相当于处理部分从(n-1)(n-2)/2 + cn 变为 lg1+lg2+...+lg(n-1) +c*n，忽略c*n
	即证明 lg1+lg2+...+lg(n-1) 是否等于nlgn
	nlgn可以写成lgn + lgn + lgn
	而lg1<lgn, lg2<lgn...
	故能收敛到O(nlgn)
	
习题2.3-7
	可以。
	思想：
	先用O(nlgn)算法对集合排序。
	然后调用二分查找。